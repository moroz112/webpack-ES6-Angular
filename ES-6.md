<h1>Основные фишки ES-6</h1>
<div><strong>LET</strong> - видна только в рамках блока, в котором обьявлена.
Повторно обьявлять нельзя - будет ошибка. Не существует до момента определения(не как var)</div>
<div><strong>ДЕСТРУКТУРИЗАЦИЯ</strong> - первое значение массива идет в переменную один
, второе во вторую переменную и тд.</br>Пример:</br>
********</br>
let [first, last] = [first, last]</br>в итоге есть let first; let last;</br>*******</div>
<div><strong>ФУНКЦИИ</strong></br>
<ul>
<li>параметры по умолчанию</li>
<li>оператор spread вместо arguments</br>*****</br>function showName(firstName, lastName, ...rest) {
                                                     alert(firstName + ' ' + lastName + ' - ' + rest);
                                                   }
                                                   
// выведет: Юлий Цезарь - Император,Рима
showName("Юлий", "Цезарь", "Император", "Рима"), где rest это какой-то массив</br>*****</li>
<li>в свойстве name в функции находится ее имя</li>
<li>Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке</li>
<li>Появился новый синтаксис для задания функций через «стрелку» =>.</li>
<li>Функции стрелки не имеют своего this. Внутри функций-стрелок – тот же this, что и снаружи</li>
<li>Функции стрелки не имеют своего arguments</li>
<li>Функции стрелки не могут быть использованы как конструкторы, тоесть с new</li>
<li>Добавлены ряд полезных методов общего назначения:
    
        str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
        str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
        str.startsWith(s) – возвращает true, если строка str начинается со строки s.
        str.repeat(times) – повторяет строку str times раз.
</li>
<li>Строки-шаблоны – для удобного задания строк (многострочных, с переменными), плюс возможность использовать функцию шаблонизации для самостоятельного форматирования</li>
</ul></div>
<div><strong>ОБЬЕКТЫ:</strong>
<ul>
<li>есть короткое свойство где значение берется из переменной с таким же именем, в качестве имени свойства можно использовать выражение</li>
<li>Функция Object.assign получает список объектов и копирует в первый target свойства из остальных.</li>
<li>Object.is(value1, value2) - новая функция для проверки равенства значений. return true if value is equal</li>
<li>В ES-2015 появилось новое ключевое слово super. Оно предназначено только для использования в методах объекта. Вызов super.parentProperty позволяет из метода объекта получить свойство его прототипа.</li>
<li>Для работы с прототипом:
    
        Object.setPrototypeOf(obj, proto) – метод для установки прототипа.
        obj.__proto__ – ссылка на прототип.
</li>
<li>
    Запись name: name можно заменить на просто name
    Если имя свойства находится в переменной или задано выражением expr, то его можно указать в квадратных скобках [expr].
    Свойства-функции можно оформить как методы: "prop: function() {}" → "prop() {}".
</li>
</ul></div>
<div><strong>КЛАССЫ</strong></br>

    Классы можно объявлять как в основном потоке кода, так и «инлайн», 
    по аналогии с Function Declaration и Expression.
    В объявлении классов можно использовать методы, геттеры/сеттеры и 
    вычислимые названия методов.
    При наследовании вызов конструктора родителя осуществляется через 
    super(...args), вызов родительских методов – через super.method(...args).

</div>
<div>
<strong>Новый примитивный тип: Symbol</strong>

    Символы – новый примитивный тип, предназначенный для уникальных 
    идентификаторов.
    Все символы уникальны. Символы с одинаковым именем не равны друг другу.
    Существует глобальный реестр символов, доступных через метод Symbol.for(name). 
    Для глобального символа можно получить имя вызовом и Symbol.keyFor(sym).

</div>
<div>
<strong>Итераторы:</strong>

    Итератор – объект, предназначенный для перебора другого объекта.
    У итератора должен быть метод next(), возвращающий объект 
    {done: Boolean, value: any}, где value – очередное значение, а 
    done: true в конце.
    Метод Symbol.iterator предназначен для получения итератора из объекта. 
    Цикл for..of делает это автоматически, но можно и вызвать его напрямую.
    В современном стандарте есть много мест, где вместо массива используются 
    более абстрактные «итерируемые» (со свойством Symbol.iterator) объекты, 
    например оператор ...spread.
    Встроенные объекты, такие как массивы и строки, являются итерируемыми, 
    в соответствии с описанным выше.

</div>